function [figout, matout] = DelayCurvesTheoretical( fignum, basic, advanced, mat )
%DelayCurvesTheoretical: Takes as input the mat structure generated by
%DelayCurvesRecur and DelayStageOne (the dynamic programming stage II and
%stage I, respectively). Generates a new figure with stopping boundaries if
%their asymptotically approximate values are known (e.g. from Chick & Gans,
%or from Chick & Frazier).
%
% Takes as input the basic and advanced data structures which were used to
% generate the computations stored in mat, and fignum, the figure number to
% use for generating the next plot. Returns figout, which can be used for
% plotting the next plot by another routine. Also output is an updated
% version of the mat structure with the upper theoretical bound as well.
%
% NB: This is actually a modified version of C&F and C&G in sense that,
% when fixedP = false, then the extra number of patients treated is brought
% into the equation for the variance.
%
% 2014 May 17: Created by Steve
%

matout = mat;
c = basic.c;                % cost per sample
delta = -log(basic.theta);  % continuous time discount rate per sample
sampvar = basic.sigma^2 * (basic.PPatients + (1-advanced.fixedP)*(basic.TMax - (mat.tvec - basic.tau))).^2;
posttvec = mat.tvec - basic.tau;    % posterior at time tvec has tvec - tau samples observed

symmetryline = basic.ICost / basic.PPatients;   % line at which one is indifferent between technologies

if delta == 0         % first check to see if results of Chick & Frazier hold (case of no discounting)
    subtitle = 'C&F';
    % NB: Formally, C&F only looked at the offline case. But we give the
    % curve for the offline learning even if the case study is for online learning 
    if c > 0          % no discounting, but yes there are positive sampling costs
        gamma = (c^2./sampvar).^(1/3);  % compute parameters for rescaling
        betainv = (c.*sampvar).^(1/3);  % 
        svec = 1 ./ (gamma .* posttvec);
        stopbound = betainv .* CFApproxBoundW(svec) + basic.ICost;  % stopping boundary at population level
        stopbound2 = - betainv .* CFApproxBoundW(svec) + basic.ICost;
    else
        posttvec = [];
        stopbound = [];
        stopbound2 = [];
    end
    if basic.online     % so far, implemented theory only for offline with no discounting
        subtitle = 'C&F offline, but online=1';
        if advanced.fixedP 
            subtitle = 'C&F offline fixedP (but online=1)';
            stopbound = basic.PPatients * mat.bndupper;     % if fixed contract at end, then set theoretical upper to that for our computation: should be 'infinity' (or mumax)
        else
            subtitle = 'C&F offline fixedP (but online=1,fixedP=0)';
        end
%        posttvec = [];
%        stopbound = [];
    end
else        % for case of discounting, recall result of brezzi and lai : same bound for online and offline with discounting
    subtitle = 'C&G';
    alpha = sqrt( delta ./ sampvar );
    betainv = sqrt( delta .* sampvar );
%    alpha = sqrt( delta ) / basic.sigma ;
%    betainv = sqrt( delta ) * basic.sigma ;
    gamma = delta;
    if c > 0
        svec = 1 ./ (gamma * posttvec);
        stopbound = betainv .* CGApproxBoundW(svec) + basic.ICost;

        % Use Theorem 4 of C&G to approximate tiem rescaling
%        kappainv = delta^(3/2) * basic.sigma / (c /basic.PPatients);
        kappainv = delta^(3/2) * sqrt(basic.PPatients)* basic.sigma / c;
        binvm = 1 / (gamma * CGApproxBoundWInv( kappainv ));
        posttvecscaled = posttvec; % allocate memory
        posttvecscaled(binvm>posttvec) = posttvec(binvm>posttvec) * binvm ./ ( binvm - posttvec(binvm>posttvec) ); 
        posttvecscaled(binvm<=posttvec) = 5*max(posttvec); % pick some really big value here, essentially infinity
        svec = 1 ./ (gamma * posttvecscaled);
        stopbound = betainv .* CGApproxBoundW(svec) + basic.ICost;
%        stopbound(binvm<=posttvec) = basic.ICost;       % put as fixed cost - essentially have perfect info (s=0 here; or tvec infty)
    else
        svec = 1 ./ (gamma * posttvec);
        stopbound = betainv .* CGApproxBoundW(svec) + basic.ICost;
    end
	stopbound2 = [];        % no quick approx formula for lower bound in this case (need access to full PDE solution: have not yet hooked it up)
end

if ~isempty(stopbound)      % if we found a theoretical boundary, then plot it
    %%%%%% Contour: Probability new treatment eventually selected 
    fignum = fignum+1; figure(fignum); 
    plot(mat.tvec,stopbound ./ basic.PPatients,'-o');       % plot CG boundary approximation (recalling that there are tau fewer samples with approxmation
    hold on;
%    UtilResizeFigureToBounds(mat);
    UtilStdizeFigure(fignum,advanced);
    plot(mat.tvec,mat.bndupper,'-.x',mat.tvec,mat.bndlower,'-.x');
    legend(sprintf('Quick Approx (%s) w/ tau = 0',subtitle),sprintf('Computed w/ tau = %f',basic.tau));
    if delta == 0       % if no discounting, then try to plot a lower boundary by reflecting the upper boundary about I/P
        if ~isempty(stopbound2)
            plot(mat.tvec,stopbound2 ./ basic.PPatients,'-o');       % plot CG boundary approximation (recalling that there are tau fewer samples with approxmation
        end
    end
    title(sprintf('%s\n %s',advanced.titlestring,subtitle),'FontSize',advanced.bigfontsize,'FontName',advanced.fontname);
    xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
    ylabel('mean reward per patient','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    %axis('square');
    if advanced.saveplot
        texttodifferentiate = 'ThmBnd';
        UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
    end
end

figout = fignum;
matout.theoryupperbnd = stopbound ./ basic.PPatients;
matout.theorylowerbnd = stopbound2 ./ basic.PPatients;

end

