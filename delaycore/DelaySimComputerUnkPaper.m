function [figout, simout] = DelaySimComputerUnkPaper(fignum, basic,advanced,mat,mu0,meanvec,normalnoise)
%DelaySimComputer: Given basic, advanced, and mat structures, a prior mean of mu0, 
% an assumed set of realized mean values in meanvec, and a set of sampling
% noise in noise, generate a bunch of simulation statistics for the delay
% sequential sampling project of Martin, Paolo and Steve.
% Assumes that the basic and advanced structures have been
% created and validated, and that the mat structure has been filled in by
% running the dynamic programming analysis implemented by DelayCurvesRecur
% and DelayStageOne (or as generated by the TestDelayIterate function).
%
% Typically this function will not be called directly, but will be called
% via DelaySimOverview().
%
% On output, creates a new simstruct structure which can be put into a mat
% structure for the analysis. The simstruct contains the following fields
%   simout.ENumSeen = outtime(:);           % mean num patient pairs seen until stopping with sequential stopping boundaries
%   simout.RealizedMean = meanvec(:);           % realized valud of mean ('true' mean of sample path)
%   simout.DecisionMean = decisionmean(:);      % posterior mean at decision
%   simout.RealizedReward = freqreward;     % total true reward assuming stopping with stopping time
%   simout.ExpectedReward = postreward;     % total expected reward asuming stopping with stopping time
%   simout.PrHitTop = abovetop;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
%   simout.PrHitBot = belowbot;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
%   simout.PrNewSelected = picknew;           % vector of indicators: true if new alternative was selected
%   simout.PrReversal = (picknew == picknewhit);           % vector of indicators: true if new alternative would be selected if selection were made at time of stopping (before waiting for pipeline data)
%   simout.PrTrueBestSelected = (newtruebest == picknew);           % vector of indicators: true if true best was selected
% Data when all Tmax samples are observed
%   simout.DecisionMeanAll = postmean(end,:)';  % posterior mean at TMax
%   simout.RealizedRewardAll = freqreward2; % total realized reward assuming stopping at TMax
%   simout.ExpectedRewardAll = postreward2; %  total expected reward assuming stopping at TMax
%   simout.PrNewSelectedAll = picknew2;           % vector of indicators: true if new alternative was selected if all TMax samples viewed
%   simout.PrTrueBestSelectedAll = (newtruebest == picknew2); % vector of indicators: true if true best was selected if all TMax samples viewed
% Data for 'trial' and for 'fixed' variations
%   simout.DecisionMeanTrial = trialpostmean(:); % posterior mean for 'trial'
%   simout.RealizedRewardTrial = freqreward3;  % actual reward for 'trial'
%   simout.PrTrueBestSelectedTrial = (newtruebest == picknew3); % vector of indicators: true if true best was selected if sample sixe equals basic.numpairs
%   simout.DecisionMeanFixed = fixedpostmean (:);  % PAOLO
%   simout.RealizedRewardFixed = freqreward4;  % PAOLO
%   simout.PrTrueBestSelectedFixed = (newtruebest == picknew4); % vector of indicators: true if true best was selected if sample size equals optimal fixed sample size
% Data is kept for the following, but statistics are not computed, as
% statistics computed over replicatins would not make sense for this data.
% By default, if the field begins with 'NoStats', no statistics will be computed for that data.
%	simout.NoStatsBoundTvec = samppathtvec(:);           % realized valud of mean ('true' mean of sample path)
%	simout.NoStatsSomePostMean = postmean(:,1:min(10,NREPS));
%	simout.NoStatsOptSFormMu0 = OptSFormMu0;
%	simout.NoStatsOpt_fix4 = Opt_fix4;
%
% 2014 04 27: Created by Steve
% 2014 08 3: Updated to account for the fact that it might not be optimal
% to always sample. The code below first assumes that tau samples or more
% should be done in order to take one into the second stage. But it might
% in fact be optimal to stop before taking tau samples. the code below
% accounts for that now. It is accounted for after the samples are done ...
% which might seem 'backwards', but the results should be correct MC
% estimates as hoped (for online: unbiased if not 'correct').
% 2014 12 19: updated by steve to account for Paolo's point that
% frequentist analysis should be run by starting sufficient statistics
% anchored at 0, rather than at frequentist boundary
% 2015 03 21: updated documentation and the fields which are computed.

MYEPS = 10e-10;

%%%%%%%%%%% Set up initilization as function of bayes or frequentist
%%%%%%%%%%% analysis and set up titles for graphics
if ~isfield(advanced,'simTmpFlag')
    advanced.simTmpFlag = true;            % default is to do a Bayesian analyis. Set to 'false' to get a frequentist analysis
end

if advanced.simTmpFlag 
    subtitle = sprintf('(Bayes mean = %.1f)',mu0);
    ftext='Ba';
else
    subtitle = sprintf('(Freq. mean = %.1f)',mu0);
    ftext='Fr';
end
if isfield(advanced,'iterateextratext')
    if ~isempty(advanced.iterateextratext)
        ftext = [ftext advanced.iterateextratext];
        subtitle = sprintf('%s %s',ftext,subtitle);
    end
end

%%%%% Do initial computations which apply to the global set of information
%%%%% about all the sample paths to be generated.

NREPS = advanced.simNumReps;                % number of replications to run
criticalthreshold = basic.ICost / basic.PPatients;  % critical threshold for deciding whether to adopt for PPatients or not

checkvals = (0:basic.TMax)';        % number of observations for checking, from 0, 1, 2, ..., TMax samples
bndtvec = basic.t0 + basic.tau + (0:(basic.TMax-basic.tau))';   % set of t values for checking bounds, data arrives tau units after sampled
samppathtvec = basic.t0 + basic.tau + checkvals;                % set of t values for which posterior can be computed
if advanced.simTmpFlag
    sampweight = (1 ./ (basic.t0+checkvals)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
    priorweight = basic.t0 ./ (basic.t0 + checkvals);         % and on prior mean.
else  % for frequentist, use sample mean. However, this causes a problem when 0 samples are used. in order to handle the case of 0 samples,
    % we mix in a very small (MYEPS) weight for mean with sample mean (essentially almost a noninformative prior with mean mu0 and variance
    % 1/MYEPS) so that the statsitics for the outputs 'look nice' - need to
    % describe this in th pape/
    sampweight = (1 ./ (MYEPS+checkvals)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
    priorweight = MYEPS ./ (MYEPS + checkvals);         % and on prior mean.
%    sampweight = ones(length(checkvals),NREPS); % weights for computing posterior: both on sum of samples...
%    sampweight(2:end,:) = (1 ./ checkvals(2:end)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
%    priorweight = zeros(length(checkvals),1);         % and on prior mean.
end
newbndupper = interp1(mat.tvec,mat.bndupper,bndtvec,'linear'); % interpolate to get boundary after 0, 1, ... samples
newbndlower = interp1(mat.tvec,mat.bndlower,bndtvec,'linear');
newbndsize = length(bndtvec);
newbndupper(newbndsize) = criticalthreshold;        % join up boundaries at terminal decision time
newbndlower(newbndsize) = criticalthreshold;
TimeInfinity = basic.t0+basic.tau+basic.TMax+1;     % a 'big' number of samples (here, pick any number strictly than largest number of effective samples in posterior distribution

obs=ones(basic.TMax,1) * meanvec' + normalnoise;    % mean plus noise in TMax observations
cumobs = [zeros(1,NREPS); cumsum(obs)]; % columns contain cumulative number of samples, from 0, 1, ..., TMax observations
%postmean = sampweight .* cumobs + priorweight * basic.mu0 * ones(1,NREPS);      % posterior mean after each observation for each sample path
postmean = sampweight .* cumobs + priorweight * mu0 * ones(1,NREPS);      % posterior mean after each observation for each sample path

% If unknown variance, then set up statistics for inference process for
% each sample path
if advanced.UnkVariance % Figure out some parameters which will help with stopping time calculation if variance is unknown
    if advanced.UnkVarianceShape == -1             % this is the shape parameter for the unknown variance. if -1, then use t0 by default. 
        baseshape = basic.t0;                      % need to have a proper prior here, and would like to have baseshape > 1 so that moments exist etc
    else
        baseshape = advanced.UnkVarianceShape;
    end
    % statistics for case of unknown variance, assume conjugate normal-gamma
    % prior, with 
    %   sigma ~ InvGamma ( xi0, chi0 ), so that E[sigma] = chi0 / (xi0-1) a priori
    %   mu | sigma ~ Normal ( mu0, sigma^2 / eta0)
    % here, we prefix the params with hp for hyperparameter, and store xi and
    % eta as column vectors for each time, the others as matrices with columns
    % for each replication, and we observe that postmean already holds what
    % would be pmmu.
    pmeta = basic.t0 + checkvals;
    pmxi = baseshape + checkvals/2;
    %pmmu = postmean;
    % preallocate posterior value of chi for each alternative and each number
    % of samples, and initialize the prior value
    % FIX: Can more stable one-pass or matrix update be implemented?
    initialchi = basic.sigma^2 * (baseshape-1);      % can try various values here for different mean values of variance a priori
    pmchi = [ initialchi*ones(1,NREPS); zeros(size(obs))];
    for i=1:basic.TMax                 % do a naive update on the value of chi iteratively (until a more stable and/or matrix implementation done)
        pmchi(i+1,:) = pmchi(i,:) + ( (postmean(i,:) - obs(i,:)).^2 * pmeta(i)/(1+pmeta(i)) ) / 2;
    end  
    poststdev = sqrt( diag(1./(pmxi-1))*pmchi );    % this is the sqrt of the posterior mean of the variance for each alternative and each 
end

% get stopping times
% find first time that sample path goes above and below the two stopping
% boundaries (or set to large number if did not go above or below. times
% are shifted by 1 (so, we subtract 1 from times in a later section)
if ~advanced.UnkVariance   % for known variance case, can use the boundaries directly
    outtop = (postmean(1:newbndsize,:) > (newbndupper * ones(1,NREPS)));
    outbot = (postmean(1:newbndsize,:) < (newbndlower * ones(1,NREPS)));
else                        % for unknown variance case, need to tweak statistics / stopping rule
	poststat = postmean(1:newbndsize,:) ./ poststdev(1:newbndsize,:) ;
    outtop = (poststat(1:newbndsize,:) > ((newbndupper/basic.sigma) * ones(1,NREPS)));
    outbot = (poststat(1:newbndsize,:) < ((newbndlower/basic.sigma) * ones(1,NREPS)));
end

[abovetop, timeup] = max(outtop);
timeup(abovetop==0) = TimeInfinity;
[belowbot, timedown] = max(outbot);
timedown(belowbot==0) = TimeInfinity;
% Find the first time that at least one of the boundaries is crossed
outtime = min(timeup,timedown);
outtime = min(outtime,newbndsize)';
abovetop = (outtime == timeup');     % reset whether went out top or bottom to be time of first of those two... 
belowbot = (outtime == timedown');   % ... as it might be that the sample path crossed both boundaries
neverout = ~abovetop & ~belowbot;   % check for possibility that neither was crossed (defensive programming)

if advanced.PLOTSIMS
    % plot out some sample paths
    numpathstoplot = min(10,NREPS);
    fignum=fignum+1; figure(fignum); hold off;
    plot(samppathtvec,postmean(:,1:numpathstoplot));
    hold on
    %plot(mat.tvec,mat.bndupper,'-.',mat.tvec,mat.bndlower,'-.');    % along with the stopping boundaries
    plot(bndtvec,newbndupper,'-.',bndtvec,newbndlower,'-.');
    plot(TimeInfinity-1,meanvec(1:numpathstoplot),'o');

    UtilStdizeFigure( fignum, advanced );
    title(sprintf('%s\n%s',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
    ylabel('mean reward','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    %axis('square');
    if advanced.saveplot
        texttodifferentiate = sprintf('Sim%s%.1f',ftext,mu0);
        UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
    end
    
    % for case of unknown variance, plots are a bit trickier due to need to
    % rescale the boundaries due to estimation of vairance and plugin for
    % variance.
    if advanced.UnkVariance 
        numpathstoplot = min(6,NREPS);
        fignum=fignum+1; figure(fignum); hold off;
        plot(samppathtvec,postmean(:,1:numpathstoplot),'-');
        hold on
        %plot(mat.tvec,mat.bndupper,'-.',mat.tvec,mat.bndlower,'-.');    % along with the stopping boundaries
        plot(bndtvec,newbndupper,'--',bndtvec,newbndlower,'--');
        plot(TimeInfinity-1,meanvec(1:numpathstoplot),'o');
        plot(bndtvec,poststat(:,1:numpathstoplot)*basic.sigma,'-.');  % try to scale posterior statistics of sample paths to new plots

        UtilStdizeFigure( fignum, advanced );
        title(sprintf('%s\n%s (unknown var)',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
        xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
        ylabel('mean reward','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
        %axis('square');
        if advanced.saveplot
            texttodifferentiate = sprintf('UVSim%s%.1f',ftext,mu0);
            UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
        end
    end
end


% Above we have computed the sample paths no matter what the value of mu0
% is, and have done so for all TMax patient pairs. That in some sense costs
% extra computing time, but it simplifies some of the coding below - and is
% defensive in the sense of not trying to duplicate code and avoiding
% proliferation of utility subroutines.
% NOW, we account for the optimal stopping boundaries as determined by the
% Stage II and Stage I calculations. In particular, mat.bestsvec should
% contain the optimal number of stage I samples to do, or more than tau if
% it is optimal to go to stage II. Here, we check if we should take NO 
% samples at all, or should take fewer than tau, or continue to stage II.
% At the end of these checks:
%   outtime: should be set to be the number of patient pairs launched total
%       -> 0 if no samples are taken at all
%       -> between 0 and tau if only stage 1 samples are taken
%       -> otherwise, the total number of patient pairs launched up to the
%       first time in which the stopping boundaries are crossed (in stage
%       II)
%   decidetime: should be set to the number of samples seen at the time of
%   the decision to pick the new treatment or existing treatment.
%       -> 0 if no samples are taken at all
%       -> outtime - tau if the decision is to be made without observing the samples 
%       -> outtime if some samples are taken and all data must be
%       observed before making a decision
% Thus, postmean(1+decidetime) should have the posterior mean at the tkme
% an alternative is made ... (when decidetime is 0, postmean(1+decidetime) 
% equals the prior mean).
OptSFormMu0 = UtilInterpSVec(mat.muvec,mu0,mat.bestsvec,basic.tau,basic.TMax); %P  compute optimal number of stage 1 samples: This might be 0, tau or more, or something in between
% for fix4, try to get the optimal one-shot duration
Opt_fix4 = UtilInterpSVec(mat.muvec,mu0,mat.OptOneShotLength,-1,basic.TMax); % compute optimal number of stage 1 samples: This might be 0, tau or more, or something in between
if ~advanced.simTmpFlag 
    OptSFormMu0 = max(1, OptSFormMu0);  % for frequentist analysis, always take at least one sample (otherwise sample mean is not defined)
    Opt_fix4 = max(1, Opt_fix4);  % for frequentist analysis, always take at least one sample (otherwise sample mean is not defined)
end

SomeInStageIOnly = false;
if OptSFormMu0 == 0     % in first stage, it is optimal not to take any samples, and to immediately select one alternative as best
    outtime = 0 * outtime;      % rather than pass the real valued 0, pass a vector of NREPS 0s so the std err is computed ok
    decidetime = 0 * outtime; % WARNING: NOTE: there is no sense of being above or below the stopping boundary in Phase I!!!!
    abovetop = ones(size(outtime)) * (mu0 * basic.PPatients > basic.ICost); % THAT SAID, We set above to 1 if there are no samples taken and we adopt the new technology
    belowbot = 1 - abovetop;
    neverout = 0 * neverout;
    hittime = outtime;
elseif OptSFormMu0 < basic.tau % in first stage it is optimal not to take a number of samples which takes us to stage 2
    outtime = OptSFormMu0 * ones(size(outtime));
    % Thanks Paolo! NOTE: Assumes that if we take some but less than tau samples in stage I, we wait for the output.
    decidetime = outtime + basic.tau;    
    % tmpvar = basic.sigma^2 * OptSFormMu0 / (basic.t0 * (basic.t0 + OptSFormMu0));
    % note: abovetop, belowbot, neverout do not really have a good meaning
    % for the case of Stage I only. So we reset these below with some
    % 'clean up' code in the space where 'SomeInStageIOnly == true'
    SomeInStageIOnly = true; % This toggle lets us update abovetop, belowbot, and neverout more cleanly below.
    hittime = outtime;
else    % it is optimal to take at least tau samples and get to stage 2
    hittime = outtime;
    outtime = outtime + floor(basic.tau) - 1;  % total number of samples at time of decision: add back in the tau samples which have not been observed at time of stopping, -1 for starting counting at 0 rather than 1
    % NOTE: in preceding time we need to add tau because outtime prior to
    % that line has value which is an index into the number of samples seen
    % up to time when stage II boundary is exceeded. We subtract 1 in
    % preceding line to get a number of samples rather than an index into
    % an array which starts with value 0, and then we need to add basic.tau
    % because another basic.tau samples have been launched by the time we 
    % stop. We take 'floor' of that to insure we have an integer number 
    decidetime = outtime + basic.tau*(1-advanced.nochangeallowed);   % time at which decision made.
    % and we can keep the abovetop, belowbot, and neverout we had computed
    % earlier. We have to add another tau time steps until last sample is
    % observed (if we are to wait for the data from those samples).
end % if statement: for having entered stage 2 sampling
discvector = basic.theta.^(decidetime);
outtime = max(0,outtime);   % defensive programming: just in case tau is 0 and it is optimal to take 0 samples

% Following adapted from Paolo's suggestion to include two more types of
% trials, at least for collecting certain statistics.
% "3" refers to the result of a sample size equal to the number of pairs
% observed in the trials we took the data from (basic.numpairs)
outtime3 = basic.numpairs ; %PAOLO
decidetime3 = outtime3  + basic.tau ; % PAOLO: (no subtraction of 1 needed, as we start with number of samples, not index into a tvec array 
% "4" refers to the optimal fixed sample size (i.e. ignoring the
% possibility of going to Stage II) as calculated by
% DelayOptimalBayesOneStage
outtime4 = floor(Opt_fix4); % optimal fixed sample size (regardless of tau)
% NOTE: Assumes that if we take some but less than tau samples in stage I, we wait for the output.
decidetime4 = outtime4 + (outtime4 > 0) * basic.tau;

% Now, compute what decison was made... need to check mean tau time units
% after boundary was crossed (unless no change is allowed post decision
getpostrows=postmean(1+hittime,:);
hitmean = diag(getpostrows);  % find mean at time all info for decision is available
getpostrows=postmean(1+outtime,:);
decisionmean = diag(getpostrows);  % find mean at time all info for decision is available
endpostmean = postmean(max(1,end-floor(basic.tau)*advanced.nochangeallowed),:)'; % posterior mean when Tmaxth patient is launched
trialpostmean = postmean (1+outtime3,:)'; % PAOLO
fixedpostmean = postmean(1+outtime4,:)';  % 

vecpatients = basic.PPatients + (1-advanced.fixedP)*(basic.TMax - outtime);
vecpatients4 = basic.PPatients + (1-advanced.fixedP)*(basic.TMax - outtime4);
criticalthresholdb = basic.ICost ./ vecpatients;
picknew = (decisionmean >= criticalthresholdb);
picknewhit = (hitmean >= criticalthresholdb);
picknew2 = (endpostmean >= criticalthreshold);
picknew3 = (trialpostmean - criticalthresholdb >= advanced.z * basic.sigma / sqrt(outtime3 + basic.t0) ); % refers to "trial": agreed to replace basic.sigma with advanced.sigma
picknew4 = (fixedpostmean >= (basic.ICost./vecpatients4)); % refers to optimal fixed sample size

if SomeInStageIOnly  % do some housekeeping for the case of a nonzero number of samples less than tau in stage I.
    abovetop = picknew; % THAT SAID, We set above to 1 if there are no samples taken and we adopt the new technology
    belowbot = 1 - abovetop;        % so, we put a MC bernoulli assignment for accepting new, randomly generated
    neverout = ones(size(neverout));    % so we can't really compute above top and below bottom meaningfully in this space
end

% mean of patients to come, plus those put in to trial if there is online learning
if basic.online
    getsumrows=cumobs(1+outtime,:); 
    onlinebenefit = basic.online*diag(getsumrows);
    onlinebenefit2 = cumobs(end,:)';
    getsumrows=cumobs(1+outtime3,:);
    onlinebenefit3 = cumobs(1+outtime3,:)';
    onlinebenefit4 = cumobs(1+outtime4,:)';
    if basic.theta < 1
        % this is a fudge factor to somewhat account for the discounting with online learning. should be unbiased estimator
        betafactors = (1 - basic.theta.^outtime) ./ (1 - basic.theta) ./ outtime;
        betafactors(outtime==0) = 1;        % fix the above division by outtime for the case when outtime is 0
        onlinebenefit(outtime>0) = onlinebenefit(outtime>0) .* betafactors(outtime > 0);
%        onlinebenefit2 = cumobs(end,:)' .* (1 - basic.theta^(basic.TMax-basic.tau*advanced.nochangeallowed)') / (1 - basic.theta) / (basic.TMax-basic.tau*advanced.nochangeallowed);
        onlinebenefit2 = cumobs(end,:)' .* (1 - basic.theta^(basic.TMax-basic.tau*advanced.nochangeallowed)') / (1 - basic.theta) / (basic.TMax);
    end
else
    onlinebenefit = 0;
    onlinebenefit2 = 0;
    onlinebenefit3 = 0;
    onlinebenefit4 = 0;
end
freqreward = discvector .* picknew .* (vecpatients .* meanvec - basic.ICost) + onlinebenefit; 
postreward = discvector .* picknew .* (vecpatients .* decisionmean - basic.ICost) + onlinebenefit; 
% If we append a 2 to the variable, it means we compute stats for all TMax
% patients in a one shot trial
freqreward2 = basic.theta^(basic.TMax+(1-advanced.nochangeallowed)*basic.tau) * picknew2 .* (basic.PPatients * meanvec - basic.ICost) + onlinebenefit2; % mean of patients to come, plus those put in to trial if there is online learning
postreward2 = basic.theta^(basic.TMax+(1-advanced.nochangeallowed)*basic.tau) * picknew2 .* (basic.PPatients * endpostmean - basic.ICost) + onlinebenefit2; % mean of patients to come, plus those put in to trial if there is online learning

freqreward3 = basic.theta^(decidetime3) .* picknew3 .* ((basic.PPatients+(1-advanced.fixedP)*(basic.TMax-basic.numpairs)) .* meanvec - basic.ICost) + onlinebenefit3; 
freqreward4 = basic.theta^(decidetime4) .* picknew4 .* (vecpatients4 .* meanvec - basic.ICost) + onlinebenefit4; 

if basic.theta < 1                    % subtract off the sampling costs, depending on whether there is discounting or not
    rewarddelta  = - basic.c * (1-basic.theta.^outtime)/(1-basic.theta);
    rewarddelta2 = - basic.c * (1-basic.theta^basic.TMax)/(1-basic.theta);
	rewarddelta3 = - basic.c * (1-basic.theta^outtime3)/(1-basic.theta); %PAOLO: sampling costs for the "trial" case
    rewarddelta4 = - basic.c * (1-basic.theta^outtime4)/(1-basic.theta); %PAOLO: sampling costs for the optimal "fixed" sample case
else
    rewarddelta = - basic.c * outtime;
    rewarddelta2 = - basic.c * basic.TMax;
	rewarddelta3 = - basic.c * outtime3; % PAOLO: as above
    rewarddelta4 =  - basic.c * outtime4; % PAOLO: as above
end
freqreward = freqreward + rewarddelta;
postreward = postreward + rewarddelta;
freqreward2 = freqreward2 + rewarddelta2;
postreward2 = postreward2 + rewarddelta2;
freqreward3 = freqreward3 + rewarddelta3; %PAOLO: as above
freqreward4 = freqreward4 + rewarddelta4; % PAOLO: as above

newtruebest = (meanvec >= criticalthresholdb);  % made this >= rather than > to allow for new one to win in case of tie, as the upper boundary is more likely to stop than lower boundary in case of tie.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% by convention, these names should differentiate plots for the associated
% numbers.
% also, start name with Pr if there are indicators, so that probability
% estimates are plotted on a correct scale
% convention is to append the text 'All' to a field name if there are
% statistics to be compared between the sequential (without 'All') and
% one-stage trial with all 'TMax' samples (with 'All')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%simout.maxPatient = basic.TMax;             % maximum number of patients which can be sampled
simout.ENumSeen = outtime(:);                % mean num patient pairs seen until stopping with sequential stopping boundaries
simout.RealizedMean = meanvec(:);           % realized valud of mean ('true' mean of sample path)
simout.DecisionMean = decisionmean(:);      % posterior mean at decision
simout.DecisionMeanAll = postmean(end,:)';  % posterior mean at TMax
simout.DecisionMeanTrial = trialpostmean(:); % PAOLO
simout.DecisionMeanFixed = fixedpostmean (:);  % PAOLO
simout.RealizedReward = freqreward;     % total true reward assuming stopping with stopping time
simout.RealizedRewardAll = freqreward2; % total realized reward assuming stopping at TMax
simout.RealizedRewardTrial = freqreward3;  % PAOLO
simout.RealizedRewardFixed = freqreward4;  % PAOLO
simout.ExpectedReward = postreward;     % total expected reward asuming stopping with stopping time
simout.ExpectedRewardAll = postreward2; %  total expected reward assuming stopping at TMax
simout.PrHitTop = abovetop;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
simout.PrHitBot = belowbot;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
simout.PrNewSelected = picknew;           % vector of indicators: true if new alternative was selected
%simout.PrNewHitSelected = picknewhit;           % vector of indicators: true if new alternative would be selected if selection were made at time of stopping (before waiting for pipeline data)
simout.PrReversal = (picknew ~= picknewhit);           % vector of indicators: true if new alternative would be selected if selection were made at time of stopping (before waiting for pipeline data)
simout.PrNewSelectedAll = picknew2;           % vector of indicators: true if new alternative was selected if all TMax samples viewed
simout.PrTrueBestSelected = (newtruebest == picknew);           % vector of indicators: true if true best was selected
simout.PrTrueBestSelectedAll = (newtruebest == picknew2); % vector of indicators: true if true best was selected if all TMax samples viewed
simout.PrTrueBestSelectedTrial = (newtruebest == picknew3); % vector of indicators: true if true best was selected if sample sixe equals basic.numpairs
simout.PrTrueBestSelectedFixed = (newtruebest == picknew4); % vector of indicators: true if true best was selected if sample size equals optimal fixed sample size

% Keep these, not for statistics, but in case they need to be plotted. By
% default, if the field begins with 'NoStats', no statistics will be
% computed for that data.
simout.NoStatsBoundTvec = samppathtvec(:);           % realized valud of mean ('true' mean of sample path)
simout.NoStatsSomePostMean = postmean(:,1:min(10,NREPS));
simout.NoStatsOptSFormMu0 = OptSFormMu0;
simout.NoStatsOpt_fix4 = Opt_fix4;

% note: true best selected is TRUE if PPatients*mean - ICost is greater
% than 0, not if mean is greater than 0

%%%%%%%%%%%%% Now, after all is said and done, print out some plots
if advanced.PLOTSIMS
    % plot out the sample paths
    fignum=fignum+1; figure(fignum); hold off;
    NBINS = max(5,ceil(advanced.simNumReps^(1/3)));     % cube root rule with minimum number of bins
    histbins = (basic.TMax / (2*NBINS))*(1:2:(2*NBINS-1))';
    hist(outtime,histbins);
%    tmp=axis; set(gca,'XTick',...);
    UtilStdizeFigure( fignum, advanced );
    %title('Histogram of patient pairs sampled');

    title(sprintf('%s\n%s',advanced.titlestring,subtitle),'FontSize',advanced.bigfontsize,'FontName',advanced.fontname);
    xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
    ylabel('Histogram of patient pairs sampled','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    %axis('square');
    if advanced.saveplot
        texttodifferentiate = sprintf('Hist%s%.1f',ftext,mu0);
        UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
    end
end

figout = fignum;

end
