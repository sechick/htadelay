function [figout, simout] = DelaySimUnkComputer(fignum, basic,advanced,mat,mu0,meanvec,obs)
%DelaySimComputer: Given basic, advanced, and mat structures, a prior mean of mu0, 
% an assumed set of realized mean values in meanvec, and a set of samples
% in obs (Tmax rows, and NREPS columns),
% generate a bunch of simulation statistics for the delay
% sequential sampling project of Martin, Paolo and Steve.
% Assumes that the basic and advanced structures have been
% created and validated, and that the mat structure has been filled in by
% running the dynamic programming analysis implemented by DelayCurvesRecur
% and DelayStageOne (or as generated by the TestDelayIterate function).
%
% Also assumes that the samples are generated from an arbitrary
% distribution rather than the normal distribution used to generate the
% boundaries.
%
% FIX: TO DO: adjust for the stopping boundary changes with UNKNOWN
% VARIANCE
%
% Typically this function will not be called directly, but will be called
% via DelaySimUnkOverview().
%
% On output, creates a new simstruct structure which can be put into a mat
% structure for the analysis. The simstruct contains the following fields
%   simout.maxPatient = basic.TMax;             % maximum number of patients which can be sampled
%   simout.outtime = outtime(:);                % num patient pairs seen until stopping with sequential stopping boundaries
%   simout.realizedmean = meanvec(:);           % realized valud of mean ('true' mean of sample path)
%   simout.decisionmean = decisionmean(:);      % posterior mean at decision
%   simout.decisionmeanall = postmean(end,:)';  % posterior mean at TMax
%   simout.realizedreward = freqreward;     % total true reward assuming stopping with stopping time
%   simout.expectedreward = postreward;     % total expected reward asuming stopping with stopping time
%   simout.realizedrewardall = freqreward2; % total realized reward assuming stopping with stopping time
%   simout.expectedrewardall = postreward2; %  total expected reward at TMax
%   simout.abovetop = abovetop;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
%   simout.newselected = picknew;           % vector of indicators: true if new alternative was selected
%   simout.truebestselected = (newtruebest == picknew);           % vector of indicators: true if true best was selected
%   simout.newselectedall = picknew2;           % vector of indicators: true if new alternative was selected if all TMax samples viewed
%   simout.truebestselectedall = (newtruebest == picknew2); % vector of indicators: true if true best was selected if all TMax samples viewed
%
% 2015 Jan 2: Steve created based on copying DelaySimComputer and creating
% this file, DelaySimUnkComputer. 
%ERROR: HASN'T BEEN COMPLETELY CHANGED - DRAFT.

MYEPS = 10e-10;

%%%%%%%%%%% Set up initilization as function of bayes or frequentist
%%%%%%%%%%% analysis and set up titles for graphics
if ~isfield(advanced,'simTmpFlag')
    advanced.simTmpFlag = true;            % default is to do a Bayesian analyis. Set to 'false' to get a frequentist analysis
end

if advanced.simTmpFlag 
    subtitle = sprintf('(Bayes mean = %.1f)',mu0);
    ftext='Ba';
else
    subtitle = sprintf('(Freq. mean = %.1f)',mu0);
    ftext='Fr';
end
if isfield(advanced,'iterateextratext')
    if ~isempty(advanced.iterateextratext)
        ftext = [ftext advanced.iterateextratext];
        subtitle = sprintf('%s %s',advanced.subtitle,subtitle);
    end
end

%%%%% Do initial computations which apply to the global set of information
%%%%% about all the sample paths to be generated.

NREPS = advanced.simNumReps;                % number of replications to run
criticalthreshold = basic.ICost / basic.PPatients;  % critical threshold for deciding whether to adopt for PPatients or not
%	threshval = (criticalthreshold - basic.c / ((1-basic.theta)) / basic.PPatients;  % SEC: Test criticalthreshold alone?

checkvals = (0:basic.TMax)';        % number of observations for checking, from 0, 1, 2, ..., TMax samples
bndtvec = basic.t0 + basic.tau + (0:(basic.TMax-basic.tau))';   % set of t values for checking bounds, data arrives tau units after sampled
samppathtvec = basic.t0 + basic.tau + checkvals;                % set of t values for which posterior can be computed
if advanced.simTmpFlag
    sampweight = (1 ./ (basic.t0+checkvals)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
    priorweight = basic.t0 ./ (basic.t0 + checkvals);         % and on prior mean.
else  % for frequentist, use sample mean. However, this causes a problem when 0 samples are used. in order to handle the case of 0 samples,
    % we mix in a very small (MYEPS) weight for mean with sample mean (essentially almost a noninformative prior with mean mu0 and variance
    % 1/MYEPS) so that the statsitics for the outputs 'look nice' - need to
    % describe this in th pape/
    sampweight = (1 ./ (MYEPS+checkvals)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
    priorweight = MYEPS ./ (MYEPS + checkvals);     % and on prior mean.
%    sampweight = ones(length(checkvals),NREPS); % weights for computing posterior: both on sum of samples...
%    sampweight(2:end,:) = (1 ./ checkvals(2:end)) * ones(1,NREPS); % weights for computing posterior: both on sum of samples...
%    priorweight = zeros(length(checkvals),1);      % and on prior mean.
end
newbndupper = interp1(mat.tvec,mat.bndupper,bndtvec,'linear'); % interpolate to get boundary after 0, 1, ... samples
newbndlower = interp1(mat.tvec,mat.bndlower,bndtvec,'linear');
newbndsize = length(bndtvec);
newbndupper(newbndsize) = criticalthreshold;        % join up boundaries at terminal decision time
newbndlower(newbndsize) = criticalthreshold;

cumobs = [zeros(1,NREPS); cumsum(obs)]; % columns contain cumulative number of samples, from 0, 1, ..., TMax observations
%postmean = sampweight .* cumobs + priorweight * basic.mu0 * ones(1,NREPS);      % posterior mean after each observation for each sample path
postmean = sampweight .* cumobs + priorweight * mu0 * ones(1,NREPS);      % posterior mean after each observation for each sample path
TimeInfinity = basic.t0+basic.tau+basic.TMax+1;     % a 'big' number of samples (here, pick any number strictly than largest number of effective samples in posterior distribution

if advanced.UnkVariance % Figure out some parameters which will help with stopping time calculation if variance is unknown
    if advanced.UnkVarianceShape == -1             % this is the shape parameter for the unknown variance. if -1, then use t0 by default. 
        baseshape = basic.t0;                      % need to have a proper prior here, and would like to have baseshape > 1 so that moments exist etc
    else
        baseshape = advanced.UnkVarianceShape - 1;
    end
    % statistics for case of unknown variance, assume conjugate normal-gamma
    % prior, with 
    %   sigma ~ InvGamma ( xi0, chi0 ), so that E[sigma] = chi0 / (xi0-1) a priori
    %   mu | sigma ~ Normal ( mu0, sigma^2 / eta0)
    % here, we prefix the params with hp for hyperparameter, and store xi and
    % eta as column vectors for each time, the others as matrices with columns
    % for each replication, and we observe that postmean already holds what
    % would be pmmu.
    pmeta = basic.t0 + checkvals;
    pmxi = baseshape + checkvals/2;
    %pmmu = postmean;
    % preallocate posterior value of chi for each alternative and each number
    % of samples, and initialize the prior value
    % FIX: Can more stable one-pass or matrix update be implemented?
    initialchi = basic.sigma^2 * baseshape;      % can try various values here for different mean values of variance a priori
    pmchi = [ initialchi*ones(1,NREPS); zeros(size(obs))];
    for i=1:basic.TMax                 % do a naive update on the value of chi iteratively (until a more stable and/or matrix implementation done)
        pmchi(i+1,:) = pmchi(i,:) + ( (postmean(i,:) - obs(i,:)).^2 * pmeta(i)/(1+pmeta(i)) ) / 2;
    end  
    poststdev = sqrt( diag(1./(pmxi-1))*pmchi );    % this is the sqrt of the posterior mean of the variance for each alternative and each 
end

% get stopping times
% find first time that sample path goes above and below the two stopping
% boundaries (or set to large number if did not go above or below. times
% are shifted by 1 (so, we subtract 1 from times in a later section)
if ~advanced.UnkVariance   % for known variance case, can use the boundaries directly
    outtop = (postmean(1:newbndsize,:) > (newbndupper * ones(1,NREPS)));
    outbot = (postmean(1:newbndsize,:) < (newbndlower * ones(1,NREPS)));
else                        % for unknown variance case, need to tweak statistics / stopping rule
    % the tweak depends on whether there is no discounting (theta=1) or
    % discounting (theta < 1). The tweak might involve changing the
    % effective number of samples and/or the height of the boundary above
    % and below a threshold. We handle the two cases now.
%	poststat = (postmean(1:newbndsize,:) - criticalthreshold) ./ poststdev + thresval;
%	poststat = postmean(1:newbndsize,:) ./ poststdev ;
	poststat = postmean(1:newbndsize,:) ./ poststdev(1:newbndsize,:) ;
    if basic.theta == 1  % case of no discounting: use approximation along lines of Chick & Frazier (Mgmt Science) 
        % First rescale time according to time acceleration idea in C&F, meaning
        % the ratio of argument in the b() function of C&F for the PDE,
        % divided by the corresponding ration in the b() function of C&F
        % when the plug-in estimator is used... 
        % But don't allow rescale below minimum values of the
        % time vector or above maximum values of time vector.
        timefudgefactor = ( (basic.sigma ./ poststdev ) ./ ((pmeta ./ (pmeta - 1))*ones(1,NREPS)) ).^(1/3);
        testtvec = max( min(bndtvec), timefudgefactor(1:newbndsize,:) .* (bndtvec*ones(1,NREPS)) );
        testtvec = min( max(bndtvec), testtvec); 
        % now time point where bound is checked is a function of sample
        % variance, so we need matrices to hold the value of the normalized
        % upper and lower boundaries, shifted by the time fudge factor
        newbnduppermat = interp1(bndtvec,newbndupper,testtvec,'linear'); 
        newbndlowermat = interp1(bndtvec,newbndlower,testtvec,'linear');
%    [newbndupper, newbndlower, newbndtvec] = DelayUnkExpandBound(basic,advanced,criticalthreshold,newbndupper,newbndlower,bndtvec);
        outtop = (poststat(1:newbndsize,:) > (newbnduppermat/basic.sigma) );
        outbot = (poststat(1:newbndsize,:) < (newbndlowermat/basic.sigma) );
    else                 % case of discounting: use approximation along lines of Chick & Gans (Mgmt Science)
        % In C&G, the argument to b() in b(1/\delta n_t) does not
        % depend on the varance, so time scale does not change. However,
        % the factor beta^{-1} is proportional to sigma x sqrt(delta / Popsize). So, we
        % scale the posterior back by sigma-hat and the true boundary back
        % by sigma, where sigma-hat is estimated sample variance, and sigma 
        % is variance assumed in PDE calcs. Note delta is the same for both plots
        % so no scaling by function of delta is needed.
        outtop = (poststat(1:newbndsize,:) > ((newbndupper/basic.sigma) * ones(1,NREPS)));
        outbot = (poststat(1:newbndsize,:) < ((newbndlower/basic.sigma) * ones(1,NREPS)));
    end
end
[abovetop, timeup] = max(outtop);
timeup(abovetop==0) = TimeInfinity;
[belowbot, timedown] = max(outbot);
timedown(belowbot==0) = TimeInfinity;
% Find the first time that at least one of the boundaries is crossed
outtime = min(timeup,timedown);
outtime = min(outtime,newbndsize)';
abovetop = (outtime == timeup');     % reset whether went out top or bottom to be time of first of those two... 
belowbot = (outtime == timedown');   % ... as it might be that the sample path crossed both boundaries
neverout = ~abovetop & ~belowbot;   % check for possibility that neither was crossed (defensive programming)


if advanced.PLOTSIMS
    % plot out some sample paths
    numpathstoplot = min(10,NREPS);
    fignum=fignum+1; figure(fignum); hold off;
    plot(samppathtvec,postmean(:,1:numpathstoplot));
    hold on
    %plot(mat.tvec,mat.bndupper,'-.',mat.tvec,mat.bndlower,'-.');    % along with the stopping boundaries
    plot(bndtvec,newbndupper,'-.',bndtvec,newbndlower,'-.');
    plot(TimeInfinity-1,meanvec(1:numpathstoplot),'o');
    
    UtilStdizeFigure( fignum, advanced );
%    title(sprintf('%s\nSample paths, stopping boundary (-.), mean (o): %s',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    title(sprintf('%s\n%s',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
    ylabel('mean reward','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    %axis('square');
    
    if advanced.saveplot
        texttodifferentiate = sprintf('Sim%s%.1f',ftext,mu0);
        UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
    end
    
    if advanced.UnkVariance % if variance is unknown, then the plots are a bit tricker to visualized, due to the tweaking above for the boundaries
        numpathstoplot = min(6,NREPS);
        fignum=fignum+1; figure(fignum); hold off;
        plot(samppathtvec,postmean(:,1:numpathstoplot),'-');
        hold on
        %plot(mat.tvec,mat.bndupper,'-.',mat.tvec,mat.bndlower,'-.');    % along with the stopping boundaries
        plot(bndtvec,newbndupper,'--',bndtvec,newbndlower,'--');
        plot(TimeInfinity-1,meanvec(1:numpathstoplot),'o');

        if basic.theta == 1  % case of no discounting: use approximation along lines of Chick & Frazier (Mgmt Science) 
            plot(bndtvec,newbnduppermat(:,1:numpathstoplot),'--',bndtvec,newbndlowermat(:,1:numpathstoplot),'--');
        else % case of discounting, along lines of C&G
            plot(bndtvec,poststat(:,1:numpathstoplot)*basic.sigma,'-.');  % try to scale posterior statistics of sample paths to new plots
        end
        
        UtilStdizeFigure( fignum, advanced );
    %    title(sprintf('%s\nSample paths, stopping boundary (-.), mean (o): %s',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
        title(sprintf('%s\n%s (unknown var)',advanced.titlestring,subtitle),'FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
        xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
        ylabel('mean reward','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
        %axis('square');

        if advanced.saveplot
            texttodifferentiate = sprintf('UVSim%s%.1f',ftext,mu0);
            UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
        end
    end
end

% Above we have computed the sample paths no matter what the value of mu0
% is, and have done so for all TMax patient pairs. That in some sense costs
% extra computing time, but it simplifies some of the coding below - and is
% defensive in the sense of not trying to duplicate code and avoiding
% proliferation of utility subroutines.
% NOW, we account for the optimal stopping boundaries as determined by the
% Stage II and Stage I calculations. In particular, mat.bestsvec should
% contain the optimal number of stage I samples to do, or more than tau if
% it is optimal to go to stage II. Here, we check if we should take NO 
% samples at all, or should take fewer than tau, or continue to stage II.
% At the end of these checks:
%   outtime: should be set to be the number of patient pairs launched total
%       -> 0 if no samples are taken at all
%       -> between 0 and tau if only stage 1 samples are taken
%       -> otherwise, the total number of patient pairs launched up to the
%       first time in which the stopping boundaries are crossed (in stage
%       II)
%   decidetime: should be set to the number of samples seen at the time of
%   the decision to pick the new treatment or existing treatment.
%       -> 0 if no samples are taken at all
%       -> outtime - tau if the decision is to be made without observing the samples 
%       -> outtime if some samples are taken and all data must be
%       observed before making a decision
% Thus, postmean(1+decidetime) should have the posterior mean at the tkme
% an alternative is made ... (when decidetime is 0, postmean(1+decidetime) 
% equals the prior mean).
SomeInStageIOnly = false;
OptSFormMu0 = ceil(interp1(mat.muvec,mat.bestsvec,mu0,'linear')); % find the optimal number of stage 1 samples. This might be 0, tau+1, or something in between
if ~advanced.simTmpFlag 
    OptSFormMu0 = max(1, OptSFormMu0);  % for frequentist analysis, always take at least one sample (otherwise sample mean is not defined)
end
if OptSFormMu0 == 0     % in first stage, it is optimal not to take any samples, and to immediately select one alternative as best
    outtime = 0 * outtime;      % rather than pass the real valued 0, pass a vector of NREPS 0s so the std err is computed ok
    decidetime = 0 * outtime; % WARNING: NOTE: there is no sense of being above or below the stopping boundary in Phase I!!!!
    abovetop = ones(size(outtime)) * (mu0 * basic.PPatients > basic.ICost); % THAT SAID, We set above to 1 if there are no samples taken and we adopt the new technology
    belowbot = 1 - abovetop;
    neverout = 0 * neverout;
    discvector = basic.theta.^(decidetime);
elseif OptSFormMu0 < basic.tau % in first stage it is optimal not to take a number of samples which takes us to stage 2
    outtime = ceil(OptSFormMu0) * ones(size(outtime));
    decidetime = outtime + floor(basic.tau);       % Thanks Paolo! NOTE: Assumes that if we take some but less than tau samples in stage I, we wait for the output.
%    tmpvar = basic.sigma^2 * OptSFormMu0 / (basic.t0 * (basic.t0 + OptSFormMu0));
    % COMPUTE POSTERIOR GIVEN THE OptSFormMu0 samples, and see if 
    SomeInStageIOnly = true; % This toggle lets us update abovetop, belowbot, and neverout more cleanly below.
    % Formally those vectors are meaningless, as there is no boundary to
    % cross in Stage I, but we assign them to be bernoulli rv with outcome
    % true if we accept the new technology for top bound, etc.
    discvector = basic.theta.^(decidetime);
else    % it is optimal to take at least tau samples and get to stage 2
    outtime = outtime + floor(basic.tau) - 1;  % total number of samples at time of decision: add back in the tau samples which have not been observed at time of stopping, -1 for starting counting at 0 rather than 1
    decidetime = outtime - floor(basic.tau)*advanced.nochangeallowed;   % time at which decision made.
    discvector = basic.theta.^(decidetime);
    % and we can keep the abovetop, belowbot, and neverout we had computed
    % earlier.
end % if statement: for having entered stage 2 sampling

% Now, compute what decison was made... need to check mean tau time units
% after boundary was crossed (unless no change is allowed post decision
getpostrows=postmean(1+decidetime,:);
decisionmean = diag(getpostrows);  % find mean at time all info for decision is available
endpostmean = postmean(max(1,end-floor(basic.tau)*advanced.nochangeallowed),:)'; % posterior mean when Tmaxth patient is launched
vecpatients = basic.PPatients + (1-advanced.fixedP)*(basic.TMax - outtime);
criticalthreshold2 = basic.ICost ./ vecpatients;
picknew = (decisionmean >= criticalthreshold2);
%picknew = (decisionmean >= criticalthreshold);
picknew2 = (endpostmean >= criticalthreshold);
getsumrows=cumobs(1+outtime,:);
if SomeInStageIOnly  % do some housekeeping for the case of a nonzero number of samples less than tau in stage I.
    getpostrows=postmean(1+decidetime,:);   % although this duplicates code below, it is easier to do this than to rework the whole thing
    postmeantest = diag(getpostrows);  % find mean at time all info for decision is available
    abovetop = picknew; % THAT SAID, We set above to 1 if there are no samples taken and we adopt the new technology
    belowbot = 1 - abovetop;        % so, we put a MC bernoulli assignment for accepting new, randomly generated
    neverout = ones(size(neverout));    % so we can't really compute above top and below bottom meaningfully in this space
end

% mean of patients to come, plus those put in to trial if there is online learning
if basic.online
    onlinebenefit = basic.online*diag(getsumrows);
    onlinebenefit2 = cumobs(end,:)';
    if basic.theta < 1
        % this is a fudge factor to somewhat account for the discounting with online learning. should be unbiased estimator
        betafactors = (1 - basic.theta.^outtime) ./ (1 - basic.theta) ./ outtime;
        betafactors(outtime==0) = 1;        % fix the above division by outtime for the case when outtime is 0
        onlinebenefit(outtime>0) = onlinebenefit(outtime>0) .* betafactors(outtime > 0);
        onlinebenefit2 = cumobs(end,:)' .* (1 - basic.theta^(basic.TMax-basic.tau*advanced.nochangeallowed)') / (1 - basic.theta) / (basic.TMax-basic.tau*advanced.nochangeallowed);
    end
else
    onlinebenefit = 0;
    onlinebenefit2 = 0;
end
freqreward = discvector .* picknew .* (vecpatients .* meanvec - basic.ICost) + onlinebenefit; 
postreward = discvector .* picknew .* (vecpatients .* decisionmean - basic.ICost) + onlinebenefit; 
% If we append a 2 to the variable, it means we compute stats for all TMax
% patients in a one shot trial
freqreward2 = basic.theta^(basic.TMax+(1-advanced.nochangeallowed)*basic.tau) * picknew2 .* (vecpatients .* meanvec - basic.ICost) + onlinebenefit2; % mean of patients to come, plus those put in to trial if there is online learning
postreward2 = basic.theta^(basic.TMax+(1-advanced.nochangeallowed)*basic.tau) * picknew2 .* (vecpatients .* endpostmean - basic.ICost) + onlinebenefit2; % mean of patients to come, plus those put in to trial if there is online learning
if basic.theta < 1                    % subtract off the sampling costs, depending on whether there is discounting or not
    rewarddelta = - basic.c * (1-basic.theta.^outtime)/(1-basic.theta);
    rewarddelta2 = - basic.c * (1-basic.theta^basic.TMax)/(1-basic.theta);
else
    rewarddelta = - basic.c * outtime;
    rewarddelta2 = - basic.c * basic.TMax;
end
freqreward = freqreward + rewarddelta;
postreward = postreward + rewarddelta;
freqreward2 = freqreward2 + rewarddelta2;
postreward2 = postreward2 + rewarddelta2;

newtruebest = (meanvec >= criticalthreshold2);  % made this >= rather than > to allow for new one to win in case of tie, as the upper boundary is more likely to stop than lower boundary in case of tie.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% by convention, these names should differentiate plots for the associated
% numbers.
% also, start name with Pr if there are indicators, so that probability
% estimates are plotted on a correct scale
% convention is to append the text 'All' to a field name if there are
% statistics to be compared between the sequential (without 'All') and
% one-stage trial with all 'TMax' samples (with 'All')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%simout.maxPatient = basic.TMax;             % maximum number of patients which can be sampled
simout.ENumSeen = outtime(:);                % mean num patient pairs seen until stopping with sequential stopping boundaries
%simout.RealizedMean = meanvec(:);           % realized valud of mean ('true' mean of sample path)
simout.DecisionMean = decisionmean(:);      % posterior mean at decision
simout.DecisionMeanAll = postmean(end,:)';  % posterior mean at TMax
simout.RealizedReward = freqreward;     % total true reward assuming stopping with stopping time
simout.RealizedRewardAll = freqreward2; % total realized reward assuming stopping at TMax
simout.ExpectedReward = postreward;     % total expected reward asuming stopping with stopping time
simout.ExpectedRewardAll = postreward2; %  total expected reward assuming stopping at TMax
simout.PrHitTop = abovetop;     % vector of indicators: did upper stopping boundary get crossed (false if bottom crossed)
simout.PrNewSelected = picknew;           % vector of indicators: true if new alternative was selected
simout.PrNewSelectedAll = picknew2;           % vector of indicators: true if new alternative was selected if all TMax samples viewed
simout.PrTrueBestSelected = (newtruebest == picknew);           % vector of indicators: true if true best was selected
simout.PrTrueBestSelectedAll = (newtruebest == picknew2); % vector of indicators: true if true best was selected if all TMax samples viewed
% note: true best selected is TRUE if PPatients*mean - ICost is greater
% than 0, not if mean is greater than 0

%%%%%%%%%%%%% Now, after all is said and done, print out some plots
if advanced.PLOTSIMS
    % plot out the sample paths
    fignum=fignum+1; figure(fignum); hold off;
    NBINS = max(4,ceil(advanced.simNumReps^(1/3)));     % cube root rule with minimum number of bins
    histbins = (basic.TMax / (2*NBINS))*(1:2:(2*NBINS-1))';
    hist(outtime,histbins);
%    tmp=axis; set(gca,'XTick',...);
    UtilStdizeFigure( fignum, advanced );
    %title('Histogram of patient pairs sampled');

    title(sprintf('%s\n%s',advanced.titlestring,subtitle),'FontSize',advanced.bigfontsize,'FontName',advanced.fontname);
    xlabel('t_0 + num patients started','FontSize',advanced.smallfontsize,'FontName',advanced.fontname); 
    ylabel('Histogram of patient pairs sampled','FontSize',advanced.smallfontsize,'FontName',advanced.fontname);
    %axis('square');
    if advanced.saveplot
        texttodifferentiate = sprintf('Hist%s%.1f',ftext,mu0);
        UtilSaveFigFile(fignum, advanced.dirstring, advanced.filestring, texttodifferentiate, advanced.graphicextension);
    end
end

figout = fignum;

end
