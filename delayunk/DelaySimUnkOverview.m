function [ figout, matout ] = DelaySimUnkOverview( fignum, basic, advanced, mat )
%DelaySimUnkOverview: Call this function to drive the generation of Monte 
% Carlo simulations for delay sequential sampling project of Martin, Paolo
% and Steve. Assumes that the basic and advanced structures have been
% created and validated, and that the mat structure has been filled in by
% running the dynamic programming analysis implemented by DelayCurvesRecur
% and DelayStageOne (or as generated by the TestDelayIterate function).
%
% IMPORTANT: Assumes sampling distribution has unknown parameters and that:
%      priorgen(muvec,[unifs])
%      sample(param,[unif]) generates samples from the distribution, given
%           param
%           Assumes sampling distribution is gaussian with known sampling
% variance and unknown mean. See DelaySimUnkOverview.m for the case of
% unknown sampling variances.
%
% If advanced.simNumReps is at least 2 (so that std dev estimates can be
% obtained), then the routine will run the simulations. The simulations
% generate advanced.simNumReps sample paths for each of the following
% scenarios:
%   - Bayesian: sample unknown mean from prior distribution, generate sample
%   paths accordingly.
%   - Frequentist: for each 'true mean' in vector advanced.simFreqDeltaVec,
%   generate sample paths which can be used for power calculations
%
% On output, creates a new mat structure with all of the attributes of the
% mat structure input, plus several structures which contain all of the
% simulation output statistics for the Bayesian and each frequentist run.
%
% 2014 Apr 27: Created by Steve
%
MYEPS = 10e-7;
matout = mat;

origPLOTSIMS = advanced.PLOTSIMS;
NREPS = advanced.simNumReps;                % number of replications to run

if NREPS < 2
    'DelaySimUnkOverview should be called with advanced.simNumReps >= 2 to get Monte Carlo Results'
else
    if advanced.CRNAcrossExperiment ~= 0  % if CRN desired across multiple calls to DelaySimUnkOverview, such as for doing across mat structure in a matvec from TestDelayIterate, reset the stream structure
        stream = RandStream('twister','Seed',int32(advanced.CRNAcrossExperiment)); % need int32() in case advanced.CRNAcrossExperiment is thought to be a logical.
        RandStream.setGlobalStream(stream);
    end
    
	% Do Bayes stuff first : CAREFUL, these instances of distributions are
	% passed by reference, not by value, so multiple of these things point
	% to the same data structure.
    ExperimentDistrib = advanced.Distribution();  % Create an instance of the sampling distribution
    ExperimentDistrib = SampleThetaBayes(ExperimentDistrib,NREPS);  % Generate NREPS samples from prior distribution
    uvec = ExperimentDistrib.Thetacdfvec;           % Get cdfs from prior distribution of sampled vector of parameters, for use in implementing CRN across means
    for i=1:length(advanced.simFreqDeltaVec)
        advanced.simTmpFlag = true;        % this is a temporary flag for use in sim computer, true for bayesian stopping bound, false for frequentist
        delta = advanced.simFreqDeltaVec(i);
        ExperimentDistrib = SetMean(ExperimentDistrib,delta);   % force the mean to match the sample mean to be evaluated (arranging other params as needed)
        if advanced.CRNAcrossBayesMu
            ExperimentDistrib = SampleThetaBayes(ExperimentDistrib,NREPS,uvec);  % Generate NREPS samples from prior distribution using CRN 
        else
            ExperimentDistrib = SampleThetaBayes(ExperimentDistrib,NREPS);  % Generate NREPS samples from prior distribution using independent samples
        end
        if (~advanced.CRN) || (i == 1)  % if CRN not wanted, or if getting first samples, generate a set of independent samples
            samples = Sample(ExperimentDistrib,basic.TMax);
            if advanced.CRN
                ucdfmat = ExperimentDistrib.Samplecdfmat;
            end
        else        % use CRN if possible across the different values of delta.
            samples = Sample(ExperimentDistrib,basic.TMax,ucdfmat);  
        end
        
        advanced.PLOTSIMS = ( (abs(abs(delta) - basic.sigma/sqrt(basic.t0)) < MYEPS) | (abs(delta) < MYEPS) ) & origPLOTSIMS;
        [fignum, simOut] = DelaySimUnkComputer(fignum,basic,advanced,mat,delta,ExperimentDistrib.ESample(:),samples);  % do simulation analysis for bayesian predictive distribution
        if i==1
        	tmp.simOut = repmat(simOut,length(advanced.simFreqDeltaVec),1);  % preallocate vector of simulation output structures for bayesian analysis
        else
        	tmp.simOut(i) = simOut;  % preallocate vector of simulation output structures for frequentist analysis
        end
    end
    if advanced.keepAllOutput
        matout.simBayesOut = tmp.simOut;
    end
    [matout.outBayes] = DelaySimAnalysis( basic, advanced, tmp.simOut );
    
	% Do frequentist stuff next
    ExperimentDistrib = advanced.Distribution();  % Create an instance of the sampling distribution
    for i=1:length(advanced.simFreqDeltaVec)
        advanced.simTmpFlag = false;        % this is a temporary flag for use in sim computer, true for bayesian stopping bound, false for frequentist
        delta = advanced.simFreqDeltaVec(i);
        ExperimentDistrib = SetMean(ExperimentDistrib,delta);   % force the mean to match the sample mean to be evaluated (arranging other params as needed)
        ExperimentDistrib = SampleThetaFreq(ExperimentDistrib,NREPS,delta);   % force the mean to match the sample mean to be evaluated (arranging other params as needed)
        advanced.PLOTSIMS = ( (abs(abs(delta) - basic.sigma/sqrt(basic.t0)) < MYEPS) | (abs(delta) < MYEPS) ) & origPLOTSIMS;

        if (~advanced.CRN) % || (i == 1)  % if CRN not wanted, or if getting first samples, generate a set of independent samples
            samples = Sample(ExperimentDistrib,basic.TMax);
%            if advanced.CRN
%                ucdfmat = ExperimentDistrib.Samplecdfmat;
%            end
        else        % use CRN if possible across the different values of delta.
            samples = Sample(ExperimentDistrib,basic.TMax,ucdfmat);  
        end
        [fignum, tmp.simOut(i)] = DelaySimUnkComputer(fignum, basic,advanced,mat,delta,ExperimentDistrib.ESample(:),samples);
    end
    if advanced.keepAllOutput
        matout.simFreqOut = tmp.simOut;
    end
    [matout.outFreq] = DelaySimAnalysis( basic, advanced, tmp.simOut );
    
end

figout = fignum;

end

